\section{Network Flow Algorithms}

\subsection{Flow networks}

\paragraph{Definition: Flow Network}
A flow network \( G = (V, E) \) is a directed graph where each edge
\( e = (u, v) \in  E \) has a positive integer capacity
\( c(u, v) > 0 \).

There are two special vertices. A source \( s \) and sink  \( t \).
There are no outgoing edges for a sink and likewise, no incoming edges
for a source.

\paragraph{Flow}
A flow in \( G \) is a function  \( f: E \to  [0, \infty) \) such that
\(  f(u, v) > 0 \). The function \( f \) must satisfy
\begin{enumerate}
  \item \textbf{Capacity Contraints:} \( f(u, v) \leq c(u, v)\), forall
     \( e(u, v) \in  E \).
  \item \textbf{Flow Conservation:} For all \( v \in V \backslash \{(s, t)\} \),
    we require \[
        \sum_{(u, v) \in  E} f(u, v) = \sum_{(v, w) \in  E}
    .\]
    That is, the incoming flow must be equal to the outgoing flow.
\end{enumerate}

\paragraph{Value of Flow}
The value of flow is defined by \[
  |f| = \sum_{v: (s, v) \in E} f(s, v)
  =
  \sum_{v: (v, t) \in  E} f(v, t)
.\]
That is, the flow leaving the source or, flow arriving at sink.

\paragraph{Goal of Flow Network}
Given a flow network, the aim is to find a flow of maximal value.

\paragraph{Integrality Theorem}
If all capacities are integers, then there exists a flow of maximum value
such that \( f(u, v) \) is an integer for all
edges  \( \left( u, v \right) \in  E \).

\paragraph{Greedy Does not Work}
The obvious greedy solution would be to send flow arbitrarity,
one-unit at a time. However, this may converge to some local maximum
that is not reflective of the true global maximum.

\paragraph{Residual Flow Network}
Given a flow network, the \textit{residual flow network} is the network
is the network made up of the leftover capacities.

\paragraph{New Edges}
Suppoe there is en edge \( e(v, w) \) with capacity  \( c_1 \)
and flow  \( f_1 \) units and edge \( e(w, v) \)
with  \( c_2, f_2 \) capacity and flow respectively.

The forward edge \( v \to  w \) allows \( c_1 - f_1 \)
additional units of flow. We can also send \( f_2 \)
units to cancel the flow to the reverse edge.

Thus, we create edges \( v \to  w \) with a capacity of
\( c_1 - f_1 + f_2 \) for the forward edge and,
\( c_2 - f_2 + f_1 \) on the backwards edge.

\paragraph{Augmenting Path}
An \textit{augmenting path} is a path from \( s \to  t \) in the residual flow network.

The capacity of an augmenting path is the capacity of its \textit{bottleneck}
edge. That is, the edge of smallest capacity.

We should then send that amount of flow along the augmenting path, recalculating
the flow and the residual capacities for each edge used.

\paragraph{Recalculating Augmented Path}
Suppose we have an augmenting path of capacity \( f \)
that includes an edge  \( v \to  w \). Then,
\begin{enumerate}
  \item Cancel up to \( f \) units of flow being sent from  \( w \to  v \)
  \item Add the remainder of theose \( f \) units to the flow being sent
    from  \( v \to  w \). That is, reverse the flow.
  \item Increase the residual capacity from \( w \to  v \) by \( f \)
    and decrease the residual capacity from  \( v \to  w \) by \( f \).
\end{enumerate}

\subsection{Ford â€“ Fulkerson Algorithm}

\paragraph{Ford - Fulkerson Method}
\begin{enumerate}
  \item Initialise flow \( f \) to  \( 0 \).
  \item While there exists an augmenting path  \( p \) in the residual
    network  \( G_f \), augment flow along  \( p \).
  \item The final flow is  \( f \).
\end{enumerate}
That is, keep adding flow through augmenting paths for as long as it is possible.

\paragraph{Proving Termination}
If all capacities are integers then, each augmenting path increases the flow
through the network by atleast one unit. However, the total flow is finite.
It cannot be larger than the sum of all the capacities.

\paragraph{Cut}
A cut in a flow network is any partition of the vertices of the underlying
graph into two subsets \( S \) and  \( T \) such that: 
\begin{enumerate}
  \item \( S \cup T = V \)
  \item \( S \cap T = \emptyset \)
  \item \( s \in S, t \in T \).
\end{enumerate}

\paragraph{Capacity of Cut}
The capacity \( c(S, T) \) of a cut  \( (S, T) \)
is the sum of capacities of all edges leaving  \( S \) and entering \( T \).
That is, \[
    c(S, T) = \sum_{(u, v) \in  E} \{ c(u, v) : u \in S, v \in T \} 
.\]


\paragraph{Flow of Cut}
The flow through a cut is the net flow from the source side, to the sink side,
\( S \to  T \).

\paragraph{Lemma: Value of Flow of Cut}
% The flow of any cut is equal to the flow of the entire network. 
T he flow of the cut, is no more than the capacity of the cut.
That is, \( |f| \leq c(S, T) \).

\paragraph{Max Flow Min Cut Theorem}
The maximual amount of flow in a flow network is equal to the capacity of the
cut of minimal capacity.

\paragraph{Time Complexity: Ford Fulkerson}
The number of augmenting paths can be up to the value of the max flow \(|f|\).
Each augmenting path takes \(O(V + R)\) (by a DFS).
In any sensibly flow network, \(V \leq E + 1\), so we may shorten
this as \(O(E)\). If this was not the case, we would have isolated vertices,
which are redundant.

Therefore, the total time comlexity is \(O(E|f|)\).

\subparagraph{The Capacity Issue}
Suppose that all capacities are \(\leq C\). Then, the length
of the input (the bits required to encode it) is \(V + E\log C\).
However, the value of the maximum flow can be as large as \(VC\). 
Therefore, \(O(E|f|)\) can be exponential. This is very cringe.

\subsection{Speeding Up Max Flow}

\paragraph{Edmonds-Karp Algorithm}
This algorithm improves upon the Ford-Fulkerson algorithm by using a
BFS instead, to find the augmenting path.
That is, it chooses the augmenting path consisting of the fewest edges.

At each step, we find next augmenting path in \(O(V + E) = O(E)\).
However, choosing paths on length may lead to prioritising edges with
small edge length, before edges with large capacity. This does not matter.

See CLRS  for a proof that the number of augmenting paths is \(EV\).
Thus, the total time complexity is \(O(VE^2)\).

\paragraph{Faster Algorithms}
Dinic's algorithm is faster as it can be done in \(O(V^2E)\) and
Preflow-Push in \(O(V^3)\). However, this are not allowed within
the context of this course.

\paragraph{Note on Practicality}
In practice, max-flow algorithms based on augmenting paths will run
alot better on average, than the worst-case complexity.

% \paragraph{Proving Maximal}
% Trivially, the max flow is less than or equal to the flow of the min-cut.
  % The difficulty is proving that the flow is equal.
%
% We can split the graph into a sink \(T\) and source \(T\) side.
% We claim that all the edges from \(S\to T\) are fully occupied
% with the flow andf, the edges from  \(T \to  S\) are empty.
% This must be true once, the Ford-Fulkerson algorithm is compute.
%

% \subsection{Applications including Maximum Bipartite Matching}
\subsection{Strategies for Alternative Max Flow Problems}

\paragraph{Networks with Multiple Sources}
If there are multiple sources and sinks, the problem is reducible by
adding a \textit{super-sink} and \textit{super-sink} to the network
where the super-source is connected to all sources with an edge of infinite
capacity. Likewike, all the sinks connect to the super-sink with infinite
capacity.

\paragraph{Networks with Vertex Capacities}
Suppose that each vertex \(v_i\) has a capcity \(C(v_i)\) which limits the total
throughput of the flow coming in and out of the vertex.
That is, \[
  \sum_{e(u, v) \in E} c(u, v) = \sum_{e(v, w)\in E}f(v, w) \leq C(v)
.\] 
This can be handled by placing an edge which bottlenecks the flow in and out of
the vertex, by splitting the vertex \(v\) into  \(v_{\mathrm{in}}, v_{\mathrm{out}}\).

Then, attach all of \(v\)'s incoming edges to \(v_{\mathrm{in}}\) and all of
its out going edges from  \(v_{\mathrm{out}}\).
Then, create an edge to connect  \(v_{\mathrm{in}}, v_{\mathrm{out}}\) such that  \[
  e^*(v_{\mathrm{in}}, v_{\mathrm{out}}) = C(v)
.\] 

\subsection{Max Flow Application: Movie Rental}

\paragraph{Problem}
Suppose that you have \(k\) movies with  \(m_i\) copies of the \(i\)-th 


