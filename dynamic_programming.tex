\section{Dynamic Programming Method}

\subsection{Introduction}
\paragraph{Dynamic programming}
Dynamic Programming is a method of solving problems that can be broken down
into subproblems and solved recursively.

\paragraph{CLRS: Four-Step Method}
\begin{enumerate}
  \item Characterize the structure of the optimal solution.
  \item Recursively define the value of an optimal solution.
  \item Compute the value of an optimal solution; typically this is done bottom-up.
  \item Construct an optimal solution from computed information.
\end{enumerate}

\paragraph{Overlapping Subproblems Property}
We must choose subproblems in a way such that the same subproblem
occurs several times in the recursion tree.
When a subproblem is solved, we store the result so that
subsequent instances of the same subproblem can be answered by a lookup table.

\paragraph{Considerations for Putting it Together}
\begin{itemize}
  \item Is the original problem a subproblem or a combination of subproblems.
  \item Order that the subproblems occur in.
  \item How many subproblems are there? How long does each take?
\end{itemize}

\subsection{Longest Increasing Subsequence}

\paragraph{Problem}
Given a sequence of \(n\) real numbers  \(A[1..n]\), find a subsequence
(not necessarily contiguous), where the values are strictly increasing.

\paragraph{Subproblem: Prefixing Lengths}
A natural choice is, for all \(i \in [1, n]\), find the length of the
longest increasing subsequence of \(A[1..i]\) that ends at  \(A[i]\).
Call this \(Q(i)\).

We try to solve \(Q(i)\)  by extending some sequence \(Q(j)\) for
\( j \leq i \).

We assume that we have solved for all \(j < i\). Then, look for a  \(j < i\)
such that \(A[j] < A[i]\). Pick a sequence \(m\) to get a maximal result and
extend it with \(A[i]\).

We stop at a base case of \(i = 1\), which is the trivial case.

The recurrence we define is \[
  Q(i) = \max\{Q(j) : j < i, A[j] < A[i]\} + 1
.\] 

The longest subsequence will correspond to the largest \(Q(i)\).

\paragraph{Time Complexity}
The \(n\)-th entry may require us to look at  \(n - 1\) entries.
We do this \(n\) times, which means the prefixing takes \(O(n^2)\)
time in total. The final solution being extracted takes \(O(n)\) and
is therefore negligible.

\paragraph{Doing Better}
This can be done in \(n \log n\). Finding such an algorithm is left as an
exercise left to the reader.

\paragraph{Correctness}
We claim that truncating the optimal solution for \(Q(i)\)
will produce an optimal solution for \(Q(m)\). 
I can't be bothered writing out why.

\paragraph{Getting Sequence Not Length}
To get the sequence, create an array of \textit{predecessors}, \(P\).
When finding \(Q[i]\), let  \(P[i] = j\) where  \(j\)
is the index chosen according to the definition of \(Q[i]\).

When backtracking through the array, when the max is found, start from
the max, then follow the predecessors until one with no predecessors is found.

\subsection{Actvitiy Selection}
\paragraph{Problem}
Input is a list of \(n\) activities with starting and finishing times  \(s_i, f_i\). 
Find the maximal duration of a subset of activities, where no two activities
take place at the same time.

This is a variation of a problem from the greedy chapter.
The greedy approach will not work for maximal duration.

\paragraph{Setup}
Sort the activities by their finishing times such that \[
  f_1 \leq f_2 \leq \cdots \leq f_n
.\] 

\paragraph{Subproblem: Maximal Duration}
Let \(P(i)\) be the subproblem of finding the duration \(t(i)\)
of a subsequence  \(\sigma(i)\), of the first  \(i\) acitivities that
 \begin{enumerate}
  \item consists of non-overlapping edges,
  \item ends with activity \(i\), 
  \item is of maximal duration.
\end{enumerate}

\(P(i)\) is solved by appending  activity \(i\) to some sequence \[
  t(i) = \max \{
    t(i) : j < i, f_j < s_i
  \}  + f_i - s_i
.\] 

There is a base case \(P(i) = f_1 - s_2\).

\paragraph{Best Solution}
The best time is \(\max(P)\).

\paragraph{Time Complexity}
\begin{enumerate}
  \item Sorting takes \(O(n \log n)\).
  \item We loop through \(n\) elements, searching  \(n - 1\) elements for the
    best  \(t\) which leads to the complexity for all subproblems
    to be \(O(n^2)\).
  \item Finding the best \(t\) is \(O(n)\).
\end{enumerate}
Thus, the overall time is \(O(n^2)\).

\paragraph{Proof of Correctness of Subproblem}
Let the optimal solution for \(P(i)\) be given by \( \{k_j\}_{j=1}^m \),
where \(k_m = i\).
The requirement is that \(\sigma' = \{k_j\}_{1}^{m - 1}\) is optimal solution
to \(P(k_{m - 1})\). This is proved by contradiction.

Suppose that instead \(P(k_{m - 1})\) is solved by a sequence
\(\tau'\) with a duration larger than  \(\sigma'\).

Then, extend \(\tau'\) with activity  \(i\). Therefore,
\(\tau_i\) will trivially have a larger duration than  \(\sigma'\).
This however contradicts the assumption of \(\sigma\) as the sequence
solving \(i\).
Hence, the optimal solution is achieved by extending the \(P(j)\) of largest duration
that supports extension of \(i\), where  \(j < i\).

\paragraph{Sequence of Activities}
To find the largest sequence, we wish not just to store \(t(i)\) with
each  \(P(i)\) but, also the predecessor \(j\) where \(P(i)\)
extends  \(P(j)\).

\subsection{Making change}
\paragraph{Problem}
You are given \(n\) types of coin denominations of integer values \[
  \{v_i\}_{i=1}^n, \text{ where } v_1 < v_2, \ldots, < v_n
.\] 
Suppose \(v_1 = 1\) and there is an unlimited amount of each \(v_i\).
This allows for it to always be possible to create change. 

\paragraph{Task}
Make change for a given integer amount \(C\), with the minimal number of coins.

\paragraph{Greedy Setup: Works}
Greedily take as many coins of the largest possible denomination \(v_n\)
that is possible. Then, do the same for \(v_{n - 1}\) and so on.

This approach works for all real-world currencies but, not for all sequences.
Consider the denominations \(\{1, 10, 15\}\) with \(C = 20\). Greedy would choose
 \(\{15, 1, 1, 1, 1, 1\} \) but the optimal is \(\{10, 10\}\).

\paragraph{Subproblem}
We will work in a bottom-up direction, finding the optimal solution for all
values up to \(C\).

\paragraph{Solving a Subproblem}
Suppose that we have found the solutions for all amounts \(j < i\)
and want to find a solution for \(i\).

Consider all coins \(v_k\) that are a part of the solution for amount \(i\).
Make up the remaining amount \(i - v_k\) with the previously computed optimal solution.

Of all the optimal solutions (being computed recursively), find the pick the one that uses
the fewest number of coins.

Suppose that we choose the coin \(m\). The optimal solution  \(P(i)\) is found
by adding a coin of denomination  \(v_m\) to  \(P(i - v_m)\).

\paragraph{Base Case}
Suppose that \(C = 0\). Then trivially, the solution has no coins.

\paragraph{Time Complexity}
Each of the \(C\) subproblems can be solved in \(O(n)\) time. As such, the time complexity
is just  \(O(nC)\).
This is \textit{not} polynomial time in terms of \(m\), as \(C\) may be unrestricted.

\paragraph{Proving Optimal Solution}
Consider an optimal solution for some \(i\).
Suppose this contains a coin of denomination  \(v_m\), for some  \(1 \leq m \leq n\).
Remobving this coin must leave an optimal solution for \(i - v_m\) by the
same cut and paste argument.

By consider all coins (of value up to \(i\)), we can pick an \(m\)
for which the optimal solution  \(i - v_m\) uses the fewest coins.

\paragraph{Finding Combinations of Coins}
If the solution also finding what combination of coins is used, then each
\(P(i)\) should also store with it, a pointer to  \(\pred(i)\), which is
the optimal solution for \(i - v_k\), alongside the value of  \(v_k\).

Then, when answering the question, we can just do a backtrace.

\paragraph{Notation}
A \(k\) that minimises \(P(i  - v_k)\) is denoted as \[
  \argmin \opt(i - v_k)
.\] 

\subsection{Knapsack Problem}

\subsubsection{Knapsack: Duplicates Allowed}
\paragraph{Problem}
There are \(n\) items. All items of kind  \(i\) are identical with weight  \(w_i\).
All weights are integers. We can take any number of items of each kind,
to fill a Knapsack of capacity \(C\).

The task is to choose a combination of items of maximal total capacity,
which fit the capacity of the Knapsack.

\paragraph{Subproblem}
The problem is effectively  a reflavoured version of the \underline{making change}
problem.

We assume that we have solved the problem for all \(j < i\). Call this value \(P(j)\).
Then, consider all item types where the \(k\)-th element has a weight
\(w_k\). If we add this item, then the rest of the bag can be
fixed with  an allocation matching the optimal solution for \(i - w_k\).
Choose the \(m\) that maximises the total value of \(P(i - w_m)\).
Then, the optimal solution for \(i\) is \(w_m + P(i - w_m)\).

There is a base case where \(\opt(0) = 0\).

\paragraph{Time Complexity}
There are up to \(C\) subproblems, each of which can be solved in \(O(n)\) time.
As such, the total overall time is  \(O(nC)\). Again, this is not polynomial in terms
of the length of the input.

\subsubsection{Knapsack: Duplicates Allowed}

\paragraph{Flaws in Previous Algorithm}
The previous algorithmn is not able to discern if a value \(v_k\) has already been used.
This breaks the rule of duplicates allowed.

\paragraph{Storing Values is not Enough}
Suppose that we follow the previous approach but store the values of what \(v_k\)
was used at that step. This is not enough. There are two main issues:
\begin{enumerate}
  \item The optimal soltion for \(i - w_k\) is not necessarily unique.
    Thus, we may record some set of items, including  \(k\) when, an equal selection of
    items is possible without \(k\). 
  \item Even if all optimal solutions for \(i - w_k\) use  \(k\), its still possible that
    there is a suboptimal solution for \(i - w_k\) that does not use \(k\).
\end{enumerate}
The reason that this fails is due to the lack of the \underline{optimal substructure property}.

\paragraph{New Way to Solve Subproblem}
For all total weights \(i\), find the optimal solution using only the first \(k\) items.
Then,
\begin{itemize}
  \item If \(k\) is used in the solution then, there is \(i - w_k\) weight left
    to fill using the first \( k - 1 \) items.
  \item If \(k\) is not used in the solution then, we must fill all  \(i\)
    units of weight with the first  \(k - 1\) items.
\end{itemize}

\paragraph{New Subproblem}
For \(0 \leq i \leq C\) and \(0 \leq k \leq n\), let  \(P(i, k)\) be the optimal
solution for determining  \(\opt(i, k)\). That is, the maximum value that can be achieved
up to  \(i\) units of weight, only using the first \(k\) items where, \(m(i, k)\) is the
(largest) index of an item in such a collection.

We have the \underline{recurrence} for \(i > 0\) and \(0 \leq k \leq n\), that  \[
  \opt(i, k) = \max (\opt(i, k - 1), opt(i - w_k, k - 1), + v_k),
\] with \(m(i, k) = m(i, k - 1)\) in the first case and \(k\) in the second.

There is a base case with \(\opt(i, k)\) if  \(i\) or \(k\) is zero and  \(m(i, k)\)
is undefined.

\paragraph{Order Matters}
When we get to \(P(i, k)\), there is an expectation that  \(P(i, k - 1)\)
and  \(P(i - w_k, k - 1)\) has already been solved.
This is guaranteed if the subproblems are solved in increasing order of \(k\)
first and then, increasing capacity of \(i\). 

\paragraph{Overall Solution and Time Complexity}
The final solution is just \(\opt(C, n)\). 

Each problem can be solved in constant time and, there are \(O(nC)\)
subproblems. Thus the overall time complexity is  \(O(nC)\)

\subsection{Balanced Partition}

\paragraph{Problem}
The input is a set of \(n\) positive integers  \(x_i \in  S\).
The task is to partition these integers into two subset  \(S_1, S_2\)
with sums \(\sum_1, \sum_2\) respectively, such that \(|\sum_1 - \sum_2|\)
is minimised.

\paragraph{Reframing the Condition}
Without loss of generatlity, assume \(\sum_1 \geq \sum_2\) and let
\(\sum\) be the sum of all elements in the set. Then, \[
  \sum_1 + \sum_2 = \sum
.\] 
As such, it follows \[
  \sum_1 - \sum_2 = 2\left( \frac{\sum}{2} - \sum_2 \right)
.\] 
That is, we want to find a subset \(S_2\) with a sum as close to \(\frac{\sum}{2}\) as possible,
without exceeding it.

\paragraph{Reframing as Knapsack}
For all \(x_i \in  S\), create an item with both weight and value equal to
\(x_i\).
Consider the knapsack problem (with no duplicates) as specified as above
with capacity of \(\frac{\sum}{2}\).

All items that are put in this knapsack can be used as \(S_1\)
while the remaining items can be a part of \(S_2\).

\subsection{Multiplying Chains of Matrices}

\paragraph{Matrix Multiplication}
The product of any two matrices \(A, B\)  \(AB\) exists if the number of
columns in \(A\) is equal to the number of rows of  \(B\).
If \(A\) is  \(m \times n\) and  \(B\) is  \(n\times p\)
then,  \(AB\) is  \(m\times p\).

Each element of \(AB\) \(ab_{i, j}\) is dot product of the \(i\)-th row of \(A\)
with the  \(j\)-th column of \(B\).
Hence, a naive solution would hvae \(m \times n \times p\) multiplications.

The order in which matrices are multiplied can drastically change the amount of
multiplications required.

\paragraph{Problem}
The input is a sequence of matrices \(A_1, A_2, \ldots, A_n\) where
\(A_i\) is of dimension  \(s_{i - 1} \times S_i\).

The task is to find the order of multiplication that minimises the number of
multiplications required.

\paragraph{Brute Force}
The brute force solution is of form \(\Omega(2^n)\).
The number of groupings \(T(n)\) is called the Catalan numbers.

\paragraph{Dynamic Approach}
There are many redundancies in the brute force approach as many of the same
prefixes are solved more than once.

A natural place to start, is just solve for the prefixes. However, this is not enough.
We need to solve for all contiguous subsequences \(A_{i + 1}, \ldots, A_j\).

\paragraph{Recurrences}
The recurrence will consider all of the possible ways to place the outermost
multiplication, splitting the chain into the product of elements
\((A_{i + 1}, \ldots A_k)(A_{k + 1}, \ldots, A_j)\).
We assume that we have solved the shortest way to multiply the sequence on the
left and, on the right.

The base-case is for a subsequence of length one where no multiplications are
required.

\paragraph{Notation for the Subproblems}
Let \(P(i, j)\) be the problem of determining \(\opt(i, j)\), which is the fewest
multiplications needed to compute the product \(A_{i + 1} \times , \ldots , A_j\).
Then, for all \(j - 1 > i\),  \[
  \opt(i,j) = \min \{
    \opt(i, k) + s_i s_k s_j + \opt(k, j): i < k < j
  \} 
.\] 

\paragraph{Order Matters}
Solving \(P(i, j)\) requires solving  \(P(i, k)\) and \(P(k, j)\) for all  \(i < k < j\).
This is guaranteed if, we solve in order of chain length.

\paragraph{Final Solution and Time Complexity}
The overall solution is \(\opt (0, n)\).
There are \(O(n^2)\) subproblems. Each of these requires \(O(n)\)
checks to find the best point of split. Thus, the time complexity is
\(O(n^3)\) as an upper bound.

However, there are many short chains and, very few short chains and,
the time complexity can be theoretically tightened. This is left as
an exercise to the reader.


\paragraph{Finding Actual Bracketing}
To find the actual location of brackets, we need to record the splitting point
that is used to obtain it. Then, we can just backtrack from the final solution.


% \subsection{Assembly line scheduling}
% \subsection{Multiplying chains of matrices}
% \subsection{Longest Common Subsequence}
% \subsection{Edit distance}
% \subsection{Bellman – Ford algorithm}
% \subsection{Floyd – Warshall algorithm}


