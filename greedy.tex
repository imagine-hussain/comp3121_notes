
\section{The Greedy Method}

\subsection{When greed pays off - foundations of the Greedy Method}

\paragraph{What is a Greedy Problem}
A greedy algorithm will divide a problem into stages and rather than exhaustively
searching through all combinations of options in all stages, it only
considers the choice that is the best for the current stage.

The idea is that the search space is reduced however, it is not
necessarily given that the solution is found using a greedy point.

\paragraph{Proofs of Greedy Algorithm}
There are two main methods of proof.
\begin{enumerate}
    \item \textbf{Greedy Stays Ahead:} This proves that at every stage,
    no other algorithm can do better than the proposed algorithm.
    \item \textbf{Exchange Argument:} Consider an optimal solution and
    gradually transform it to the solution found by the proposed algorithm
    without making it any worse.
\end{enumerate}
These methods are analogous to proof by induction and contradiction
respectively.

\subsection{Activity Selection problem}
\paragraph{Problem Statement}
There is a list of \(n\) activities with starting times \(s_i\).
and finishing time \(f_i\). Schedule the activities such that no two
activities overlap. Maximise for the total number of activities.

\paragraph{Solution}
Among the activities that do not conflict with the previously chosen
activities, choose the activity with the earliest end-time.
Ties may be broken arbitrarily.

\paragraph{Proof}
Correctness is proved with the \textit{exchange argument} to show that
any optimal solution can be transformed into our greedy solution.
\begin{enumerate}
    \item Find the first place at which the optimal solution violates
    the greedy choice.
    \item Replace the activity chose with the greedy choice.
    Clearly, the number of activities is the same.
    Also, we know there are no conflicts that have been created because,
    we are working left-to-right and have chosen the first conflict.
    So, no conflict happens before the start of the greedy's choice.
    Also, the finish time of greedy is no greater than the finish
    time of the optimal solution. As such, there is no conflict
    on the right-side of the greedy choice either.
\end{enumerate}

\paragraph{Complexity}
We can sort using the finishing time as the key in \(n\log n\).
Then, loop through all the activities linearly for a total
time of \(O(n \log n)\).


% \subsection{Discrete (0â€“1) Knapsack Problem}
% \subsection{File compression: Huffman Codes}
% \subsection{Directed acyclic graphs and topological sorting}
% \subsection{Dijkstra's algorithm}
% \subsection{Minimum spanning trees}

% \subsection{Cell Towers}

% \paragraph{Problem}

% \paragraph{}

\subsection{Job Lateness}
\paragraph{Problem}
At a start time \(T_0\) and a list of \(n\) jobs with duration times
\(t_i\) and deadlines \(t_i\).

Assume that only one job can be done at a time and all jobs need to
be completed

\paragraph{Solution}
Ignore the duration. Then, choose jobs in terms of ascending deadlines.

\paragraph{Proof}
Consider an optimal solution.
We say \(i, j\) is an inversion if \(i\) is scheduled before
\(j\) but, \(j\) is scheduled after \(i\).

